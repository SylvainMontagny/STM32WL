#include "send_raw_lora.h"
#include "radio.h"
#include "radio_ex.h"
#include "sys_app.h"

volatile uint32_t RadioTxDone_flag = 0;

void LoRa_Send(void){

	RadioEvents_t LoRa_RadioEvents;
	TxConfigGeneric_t LoRa_TxConfig;

	uint8_t payload[] = { 0x01 , 0x02 , 0x03 , 0x04 , 0x05 };
	uint8_t payloadLen = 5;

	// saisie des caracteres au clavier.

	APP_LOG_COLOR(GREEN);
	APP_LOG(0, 1, "\tSend Raw LoRa Packet\r\n");

	// Radio callback configuration
	LoRa_RadioEvents.TxDone = LoRa_OnTxDone;
	LoRa_RadioEvents.RxDone = LoRa_OnRxDone;
	LoRa_RadioEvents.TxTimeout = LoRa_OnTxTimeout;
	LoRa_RadioEvents.RxTimeout = LoRa_OnRxTimeout;
	LoRa_RadioEvents.RxError = LoRa_OnRxError;
	Radio.Init(&LoRa_RadioEvents);

	// Radio parameters configuration
	LoRa_TxConfig.lora.Bandwidth = RADIO_LORA_BW_125;
	LoRa_TxConfig.lora.SpreadingFactor = 7;
	LoRa_TxConfig.lora.Coderate = CR4o5;
	LoRa_TxConfig.lora.LowDatarateOptimize = DEFAULT_LDR_OPT;
	LoRa_TxConfig.lora.PreambleLen = LORA_PREAMBLE_LENGTH;
	LoRa_TxConfig.lora.LengthMode = RADIO_LORA_PACKET_VARIABLE_LENGTH; // edit sylvain default RADIO_LORA_PACKET_VARIABLE_LENGTH, OK c'est la bonne valeur Ã  priori
	LoRa_TxConfig.lora.CrcMode = RADIO_LORA_CRC_ON;
	LoRa_TxConfig.lora.IqInverted = RADIO_LORA_IQ_NORMAL; // edit sylvain default = RADIO_LORA_IQ_NORMAL , c'est bien NORMAL qu'il faut, sinon on inverse les upchirp en downchirp

	Radio.RadioSetTxGenericConfig(GENERIC_LORA, &LoRa_TxConfig, EMISSION_POWER, TX_TIMEOUT_VALUE);
	Radio.SetPublicNetwork(true);
	Radio.SetChannel(868100000);
	Radio.Send(payload, payloadLen);

	UTIL_SEQ_WaitEvt(1 << CFG_SEQ_Evt_RadioOnTstRF); // Wait event generated by LoRaOnTxDone()
    Radio.Sleep();

}

void LoRa_OnTxDone(void){
	  RadioTxDone_flag = 1;
	  UTIL_SEQ_SetEvt(1 << CFG_SEQ_Evt_RadioOnTstRF);
}

void LoRa_OnRxDone(void){
}

void LoRa_OnTxTimeout(void){
}

void LoRa_OnRxTimeout(void){
}

void LoRa_OnRxError(void){
}


